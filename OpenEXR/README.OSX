OpenEXR has only been tested on OS X 10.2 (Jaguar).  There's a bug in
Apple's istream::read implementation in 10.2 that breaks OpenEXR when
an end-of-file is reached.  There is a workaround for the bug, but it's
too ugly to add to the OpenEXR official source, and it requires some
extra work in any code that uses OpenEXR, anyway.

The workaround and the details of the bug are shown below.  We don't
guarantee that it works in all cases.  Thanks to our resident Mac
programming guru, Paul Schneider <pauls@ilm.com>, for the workaround and 
bug details.  


Workaround:
------------

You can hack checkError (istream&) in ImfIO.cpp to clear the error bits on 
the stream.  This is a horribly fragile solution, because a) those bits might
be correctly set if you really did try to read off the end of the
stream, and b) after a call to istream::read that grabs the last byte in
the stream, the stream is unusable until someone calls checkError on it. 
OpenEXR and the confidence tests always call checkError after reading
a stream, but you'll need to do this in your code, as well, to make this
work properly.

Change checkError (std::istream &is) in ImfIO.cpp to read as follows:

bool
checkError (std::istream &is)
{
    if (!is)
    {
        if (errno)
            Iex::throwErrnoExc();

        // HACK - this is a workaround to a bug in Apple/gcc's
        // implementation of istream::read.  Bug is present
        // as of the August 2002 developer's CD.
        is.clear (std::ios_base::goodbit);

        return false;
    }

    return true;
}


Bug details:
------------

In gcc 3.1, basic_istream::read is implemented starting at line 771 in
bits/istream.tcc.  Note that the variable __c is read at the
end of the loop at line 790.  The result is that when the loop is
finished, __c contains the character *after* the last character inserted
into the output array __s.  This means that if the last byte of the stream
is requested, __c contains EOF.  After the loop, if __c contains EOF, the
stream's eofbit and failbit are set (line 793).  This is incorrect if all
of the requested characters were inserted into the output stream before
EOF was read.  One possible fix would be to add a check for 
_M_gcount < __n on line 792, in addition to the check for __eof.

